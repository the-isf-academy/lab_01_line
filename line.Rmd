---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import pandas as pd
from helpers import clamp_database, create_graph, draw, draw_line, add_loss
```

# Setting up our data

In the past few classes, we dug into the data from our social media survey. You can run the cell below as a reminder of what it looks like.

```{python}
df = pd.read_csv('social_media_use_clean.csv')
df
```

For this lab, we're going to focus on two variables of that data to see how related they are.

Below, we've chosen to use the `grade` variable and the `sm_accounts` variable. This will help us see whether there is a relationship between students' grade level and the number of social media accounts they reported having. *You can play around with other variables if you'd like to see what other relationships exist in our data.*

We're also setting up variables to define the domain we want all of our data to fall within. *You can play with this piece as well.*

```{python}
x_var = 'grade'
y_var = 'sm_time'
x_domain = (5,12)
y_domain = (0,50)
```

To get you started, we'll clean up the data a little by focusing on the two variables specified above, removing and reponses where people didn't answer the question for these variables, and making sure the data fits within a specified domain `x_domain` and `y_domain`.

We also moved the data from a special data structure called a `dataframe` into a structure you're more familiar with, a `list`.

```{python}
df_two_col = df[[x_var, y_var]]
df_two_col = df_two_col.dropna()
df_two_col_clamp = clamp_database(df_two_col, (5,12), (0,50))
data_points_list = [(x,y) for x, y in df_two_col.values]
```

# Plotting the data

Now, we'll plot the data on a scatter plot. We're using a different tool to plot the data, but it's similar to the tool you created in the scatter plot lab earlier this unit.

```{python}
ax = create_graph(x_var, y_var)
draw(data_points_list, ax)
```

```{python}
ax = create_graph(x_var, y_var)
draw(data_points_list, ax)

m = .2
b = .3
draw_line(m, b, ax)
```

```{python}
def loss(m,b,data_points_list):
    sqerror = 0
    for point in data_points_list:
        line_y = m*point[0] + b
        distance = point[1] - line_y
        sqerror += pow(distance,2)
    return sqerror/len(data_points_list)
```

```{python}
ax = create_graph(x_var, y_var)
draw(data_points_list, ax)

m = 0.2
b = .3
draw_line(m, b, ax)
line_loss = loss(m, b, data_points_list)
add_loss(line_loss, ax)
```

```{python}
min_loss = loss(0,0, data_points_list)
min_m = 0
min_b = 0
for m in range(0,int(2/.25)):
    for b in range(0,10):
        curr_loss = loss(m*.25, b, data_points_list)
        if curr_loss < min_loss:
            min_loss = curr_loss
            min_m = m*.25
            min_b = b

(min_m, min_b)
(min_m, min_b, loss(min_m, min_b, data_points_list))
            
```

```{python}
# %matplotlib notebook
```

```{python}
import numpy as np
import matplotlib.pyplot as plt
import time
```

```{python}
def pltsin(ax, colors=['b']):
    x = np.linspace(0,1,100)
    if ax.lines:
        for line in ax.lines:
            line.set_xdata(x)
            y = np.random.random(size=(100,1))
            line.set_ydata(y)
    else:
        for color in colors:
            y = np.random.random(size=(100,1))
            ax.plot(x, y, color)
    fig.canvas.draw()
```

```{python}
fig,ax = plt.subplots(1,1)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_xlim(0,1)
ax.set_ylim(0,1)
for f in range(5):
    pltsin(ax, ['b', 'r'])
    time.sleep(1)
```

```{python}

```
